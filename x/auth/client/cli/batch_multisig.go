package cli

import (
	"fmt"

	"github.com/tendermint/tendermint/crypto/multisig"

	"github.com/cosmos/cosmos-sdk/client/context"
	crkeys "github.com/cosmos/cosmos-sdk/crypto/keys"
	"github.com/cosmos/cosmos-sdk/x/auth/client/utils"
	"github.com/cosmos/cosmos-sdk/x/auth/types"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"

	"github.com/cosmos/cosmos-sdk/client"
	"github.com/cosmos/cosmos-sdk/client/flags"
	"github.com/cosmos/cosmos-sdk/codec"
)

func GetBatchMultisigCommand(codec *codec.Codec) *cobra.Command {
	cmd := &cobra.Command{
		Use:    "multisign-batch [file] [name] [[signature-file]...]",
		Short:  "Assemble multisig transactions",
		Long:   `Assemble a batch of multisig transactions generated by batch sign command.`,
		PreRun: preSignCmd,
		RunE:   makeBatchMultisigCmd(codec),
		Args:   cobra.MinimumNArgs(3),
	}

	cmd.Flags().String(client.FlagOutputDocument, "",
		"write the result to the given file instead of the default location")

	cmd.Flags().String(
		FlagMultisig, "",
		"Address of the multisig account on behalf of which the transaction shall be signed",
	)

	return flags.PostCommands(cmd)[0]
}

func makeBatchMultisigCmd(cdc *codec.Codec) func(cmd *cobra.Command, args []string) error {
	return func(cmd *cobra.Command, args []string) error {
		_ = context.NewCLIContext().WithCodec(cdc)
		txBldr := types.NewTxBuilderFromCLI()

		out, err := setOutput()
		if err != nil {
			return errors.Wrap(err, "error with output")
		}

		txs, err := utils.ReadStdTxsFromFile(cdc, args[0])
		if err != nil {
			return errors.Wrap(err, "error extracting txs from file")
		}

		multisigInfo, err := txBldr.Keybase().Get(args[1])
		if err != nil {
			return errors.Wrap(err, "error getting keybase multisig account")
		}
		if multisigInfo.GetType() != crkeys.TypeMulti {
			return fmt.Errorf("%q must be of type %s: %s", args[1], crkeys.TypeMulti, multisigInfo.GetType())
		}

		var signatureBatch [][]types.StdSignature
		for i := 2; i < len(args); i++ {
			signatures, err := utils.ReadSignaturesFromFile(cdc, args[i])
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error getting signatures from file %s", args[i]))
			}

			signatureBatch = append(signatureBatch, signatures)
		}

		sequence := txBldr.Sequence()
		for i, tx := range txs {
			txBldr = txBldr.WithSequence(sequence)
			sigBytes := types.StdSignBytes(
				txBldr.ChainID(), txBldr.AccountNumber(), txBldr.Sequence(),
				tx.Fee, tx.GetMsgs(), tx.GetMemo(),
			)
			multisigPub := multisigInfo.GetPubKey().(multisig.PubKeyMultisigThreshold)
			multisigSig := multisig.NewMultisig(len(multisigPub.PubKeys))

			for _, signBatch := range signatureBatch {
				if ok := signBatch[i].PubKey.VerifyBytes(sigBytes, signBatch[i].Signature); !ok {
					return fmt.Errorf("couldn't verify signature")
				}
				if err := multisigSig.AddSignatureFromPubKey(signBatch[i].Signature, signBatch[i].PubKey, multisigPub.PubKeys); err != nil {
					return err
				}
			}

			newStdSig := types.StdSignature{Signature: cdc.MustMarshalBinaryBare(multisigSig), PubKey: multisigPub}
			newTx := types.NewStdTx(tx.GetMsgs(), tx.Fee, []types.StdSignature{newStdSig}, tx.GetMemo())

			json, err := cdc.MarshalJSON(newTx)
			if err != nil {
				return errors.Wrap(err, "error marshalling tx")
			}

			_, err = fmt.Fprintf(out, "%s\n", json)
			if err != nil {
				return errors.Wrap(err, "error writing to output")
			}

			sequence++
		}

		return nil
	}
}
